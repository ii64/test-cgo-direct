# cgo-direct

A workaround to call your external library function without CGo overhead.

- [x] cgo direct call (no CGo wrapper, example in SystemV amd64)
- [x] cross platform compat (with `zig cc`) *

\* for direct call, be sure you have prepared right calling convention, like eg. Microsoft x64 had `RCX` as their first argument. (Also please check if caller is from G/T)

This due to compiler generateed results (specified by `-target` on `Makefile`) is platform specific (although the source is **not**), and also the linker (eg. ELF, PE, MACH-O, etc etc).

On `asm2asm` approach, transpiler consume ATT-syntax asm generated by `clang` and outputting Go's Plan9. `clang` target is not specified so the reasonable fallback is the platform that runs it.

Snipped from [asm2asm/asm2asm.py](https://github.com/chenzhuoyu/asm2asm/blob/5e85f0dbbd2eb4768d8413c326e5540612c86fae/asm2asm.py#L828-L846) is SystemV amd64 ABI for caller to put arguments:
```python
ARGS_ORDER = [ Register('rdi'), Register('rsi'), Register('rdx'),
    Register('rcx'), Register('r8'),  Register('r9') ]
```
The platform boundary is on Asm wrapper that call transpiled native function,
that's why Windows support for [bytedance/sonic](https://github.com/bytedance/sonic/pull/228) _just work_ like **magic**.

Screenshoot for this repo:
![fig0][0]

## Compile

```bash
make build-native
# compile nodebug
make build
# compile debug
make debug
# compile debug and dump asm
make dmp
```

## Related

- https://words.filippo.io/rustgo/
- https://github.com/chenzhuoyu/asm2asm

[0]: assets/fig.png